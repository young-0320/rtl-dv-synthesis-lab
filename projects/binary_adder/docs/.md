## 골든 모델 설계 오류 분석 보고서

본 보고서는 초기 C++ 골든 모델 설계 과정에서 발생한 논리적 오류를 분석하고, 향후 대규모 가속기 설계 시 동일한 실수를 방지하기 위한 아키텍처 원칙을 정의합니다.

### 1. [직관적 비유] 채점관의 오류

* **오류 상태:** 채점관(골든 모델)이 정답지(텍스트 파일)만 만들면 되는데, 수험생(RTL 설계)이 문제를 푸는 과정(리플 캐리 에더의 체인 동작)과 똑같은 방식으로 연습장에 수식을 전개하려고 고집했습니다.
* **정상 상태:** 채점관은 계산기(CPU의 산술 연산자)를 두드려 즉각적으로 답만 도출하고 다음 채점으로 넘어가야 합니다.

### 2. [핵심 메커니즘] 코드에 나타난 3대 안티 패턴(Anti-Pattern)

1. **상태(State)가 없는 조합 회로에 객체 지향(OOP) 남용**
   * **증상:** 1비트 가산기를 `class FullAdder`로 정의하고, 내부에 `half_sum`, `carry_in` 등의 `private` 변수를 선언하여 상태를 저장하려 했습니다.
   * **분석:** 조합 회로(Combinational Logic)는 메모리가 없는 순수 함수(Pure Function)입니다. 클래스와 상태 변수를 도입하는 순간 메모리 할당 및 접근 오버헤드가 발생하며, 이는 하드웨어의 물리적 실체와도, 소프트웨어의 최적화 방향과도 완전히 어긋납니다.
2. **계층적 조립(Hierarchy)에 의한 함수 호출 오버헤드**
   * **증상:** N비트 가산기를 만들기 위해 1비트 가산기 함수를 N번 호출하는 루프를 구성하려 했습니다.
   * **분석:** 하드웨어는 선을 연결하기 위해 하위 모듈의 조립이 필수적이지만, 소프트웨어는 CPU의 강력한 64비트 ALU를 사용할 수 있습니다. `+` 연산자 하나로 끝날 1클럭짜리 연산을 수십 번의 함수 호출(Function Call)로 쪼개어 시뮬레이션 속도를 수십 배 저하시키는 결과를 초래했습니다.
3. **추상화 계층(Abstraction Level)의 혼동**
   * **증상:** 하드웨어의 포트 개수(출력 2개)를 맞추기 위해 C++의 리턴 방식을 복잡하게 고민했습니다.
   * **분석:** 소프트웨어와 하드웨어는 데이터를 인코딩하는 방식이 다릅니다. 소프트웨어는 데이터를 압축하여(Bit Packing) 하나의 자료형(`uint8_t` 등)에 담아 전달하고 파일 입출력(I/O) 효율을 극대화해야 함을 간과했습니다.

### 3. [Low-level 동작] 향후 설계를 위한 행동 강령 (Action Items)

다가올 2D 이미지 필터나 대규모 다중 안테나(MIMO) 신호처리 알고리즘 가속기 설계 시, 골든 모델 작성에 다음 원칙을 엄격히 적용해야 합니다.

* **Rule 1: Flat Math (평탄화된 수학)**
  * 내부 파이프라인, 곱셈기 트리, 가산기 체인 등 물리적 아키텍처는 C++ 코드에서 완전히 소거합니다.
  * 시스템 입력이 주어지면 C++의 선형대수 연산이나 단순 산술 연산자만으로 최종 정답 행렬/배열을 한 번에 도출합니다.
* **Rule 2: Untimed, Bit-Accurate (시간 배제, 비트 정확도 보장) -> 핵심**
  * 클럭(Clock) 단위의 타이밍은 모사하지 않습니다.
  * 단, 하드웨어 데이터패스에서 발생하는 **양자화 절삭(Truncation), 오버플로우(Overflow), 포화(Saturation)** 처리는 비트 마스킹과 쉬프트 연산을 통해 100% 동일하게 모사하여 단 1비트의 오차도 없는 정답을 출력해야 합니다.
